SDsugarConsumed <- sd(a1)
SugarZscore <- ((a1-MeanSugarConsumed)/(SDsugarConsumed))
#p2 = plot(SugarZscore, type="o", col="green")
# z-value for fat
a2 <- CleanHFSSQuals$data.Fatg
MeanFatConsumed <- mean(a2)
SDFatConsumed <- sd(a2)
FatZscore <- ((a2-MeanFatConsumed)/(SDFatConsumed))
#p1 = plot(FatZscore, type="o", col="red")
#z value for sodium
a3 <- CleanHFSSQuals$data.Sodiummg
MeanSodiumConsumed <- mean(a3)
SDSodiumConsumed <- sd(a3)
SodiumZscore <- ((a3-MeanSodiumConsumed)/(SDSodiumConsumed))
AverageZScore <- (SugarZscore+FatZscore+SodiumZscore)/3
AvgZ <- data.frame(AverageZScore)
CleanHFSSQualsAvgZ <- cbind(CleanHFSSQuals,AvgZ)
#Group data based on education level
CleanHFSSQuals1 <- CleanHFSSQualsAvgZ
CleanHFSSQuals1$data.qual7[CleanHFSSQuals1$data.qual7 != 1] <- NA #sets all negative values to NA
CleanHFSSQuals1 <- CleanHFSSQuals1 %>% na.omit() #omits all rows with NA in them
MeanZ1 <- sum(CleanHFSSQuals1$AverageZScore)/nrow(CleanHFSSQuals1)
CleanHFSSQuals2 <- CleanHFSSQualsAvgZ
CleanHFSSQuals2$data.qual7[CleanHFSSQuals2$data.qual7 != 2] <- NA #sets all negative values to NA
CleanHFSSQuals2 <- CleanHFSSQuals2 %>% na.omit() #omits all rows with NA in them
MeanZ2 <- sum(CleanHFSSQuals2$AverageZScore)/nrow(CleanHFSSQuals2)
CleanHFSSQuals3 <- CleanHFSSQualsAvgZ
CleanHFSSQuals3$data.qual7[CleanHFSSQuals3$data.qual7 != 3] <- NA #sets all negative values to NA
CleanHFSSQuals3 <- CleanHFSSQuals3 %>% na.omit() #omits all rows with NA in them
MeanZ3 <- sum(CleanHFSSQuals3$AverageZScore)/nrow(CleanHFSSQuals3)
CleanHFSSQuals4 <- CleanHFSSQualsAvgZ
CleanHFSSQuals4$data.qual7[CleanHFSSQuals4$data.qual7 != 4] <- NA #sets all negative values to NA
CleanHFSSQuals4 <- CleanHFSSQuals4 %>% na.omit() #omits all rows with NA in them
MeanZ4 <- sum(CleanHFSSQuals4$AverageZScore)/nrow(CleanHFSSQuals4)
CleanHFSSQuals5 <- CleanHFSSQualsAvgZ
CleanHFSSQuals5$data.qual7[CleanHFSSQuals5$data.qual7 != 5] <- NA #sets all negative values to NA
CleanHFSSQuals5 <- CleanHFSSQuals5 %>% na.omit() #omits all rows with NA in them
MeanZ5 <- sum(CleanHFSSQuals5$AverageZScore)/nrow(CleanHFSSQuals5)
CleanHFSSQuals6 <- CleanHFSSQualsAvgZ
CleanHFSSQuals6$data.qual7[CleanHFSSQuals6$data.qual7 != 6] <- NA #sets all negative values to NA
CleanHFSSQuals6 <- CleanHFSSQuals6 %>% na.omit() #omits all rows with NA in them
MeanZ6 <- sum(CleanHFSSQuals6$AverageZScore)/nrow(CleanHFSSQuals6)
CleanHFSSQuals7 <- CleanHFSSQualsAvgZ
CleanHFSSQuals7$data.qual7[CleanHFSSQuals7$data.qual7 != 7] <- NA #sets all negative values to NA
CleanHFSSQuals7 <- CleanHFSSQuals7 %>% na.omit() #omits all rows with NA in them
MeanZ7 <- sum(CleanHFSSQuals7$AverageZScore)/nrow(CleanHFSSQuals7)
CleanHFSSQuals8 <- CleanHFSSQualsAvgZ
CleanHFSSQuals8$data.qual7[CleanHFSSQuals7$data.qual8 != 8] <- NA #sets all negative values to NA
CleanHFSSQuals8 <- CleanHFSSQuals8 %>% na.omit() #omits all rows with NA in them
MeanZ8 <- sum(CleanHFSSQuals8$AverageZScore)/nrow(CleanHFSSQuals8)
MeanZs <- c(MeanZ1, MeanZ2, MeanZ3, MeanZ4, MeanZ5, MeanZ6, MeanZ7, MeanZ8)
Qs <- c(1:8)
Q7 <- CleanHFSSQuals$data.qual7
par(mfrow = c(1,2))
plot(Q7,AverageZScore)
plot(Qs, MeanZs, pch=16, col="red")
abline(lm(MeanZs ~ Qs), col="blue")
#dev.off()
#plot(AverageZScore, pch = 20, col = factor(QL)) #scatter plot, pch means plot character with a list in r.
#legend("topright", legend = levels(factor(QL)), pch = 19, col = factor(levels(factor(QL)))) # legend with function assigning colours automatically
q()
install
update
sessionInfo()
q()
rm(list = ls())
require(mice)
require(lattice)
set.seed(123) # Means our outcomes will be replicable
help(boys)
md.pattern(boys)
mpat <- md.pattern(boys)
sum(mpat[, "gen"] == 0) # how many patterns where is gen missing
# Next we will check to see if missing data in one variable is related to another variable.
# Choose to see if missing "gen" data points are dependent on "age"
# One way to do this is to create two histograms for age, one for where "gen" is missing and one where it isn't
# and see if there is a common pattern between them
# We first create a missingness indicator (1 for when data is missing and 0 for when its there)
R <- is.na(boys$gen)
histogram(~ gen, data = boys)
histogram(~age|R, data=boys) # spread of age data given R, will create two histograms
# We see in this latest histogram that the missingness in gen is not evenly spread across age
imp1 <- mice(boys, print=FALSE)
summary(boys)
summary(complete(imp1))
summary(with(imp1, mean(tv))) # to get the information only on mean of 'tv' rather than all the other stuff
head(mammalsleep)
md.pattern(mammalsleep)
rm(list = ls()) # clean workspace
# New dataset we're looking at
head(mammalsleep)
md.pattern(mammalsleep)
imp <- mice(mammalsleep, maxit = 10, print=F) # 5 imputed algorithms with 10 iterations
plot(imp)
fit1 <- with(imp, lm(sws ~ log10(bw) + odi), print=F)
pool(fit1)
# New dataset we're looking at
head(mammalsleep)
impNew <- mice(mammalsleep[ , -1], maxit = 10, print=F)
fit2 <- with(impnew, lm(sws ~ log10(bw) + odi))
fit2 <- with(impNew, lm(sws ~ log10(bw) + odi))
pool(fit2)
help("mammalsleep")
# Vignette 4  - Passive imputation and Post-processing --------------------------------------------------------------------------------
# The goal of passive imputation is to maintain the consistency among different transformations of the same data
rm(list = ls())
require(mice)
require(lattice)
set.seed(123) # Means our outcomes will be replicable
ini <- mice(mammalsleep[, -1], maxit=0, print=F)
meth<- ini$meth
meth
pred <- ini$pred
pred <- ini$predictorMatrix
pred[c("sws", "ps"), "ts"] <- 0
meth["ts"]<- "~ I(sws + ps)"
pas.imp <- mice(mammalsleep[, -1], meth=meth, pred=pred, maxit=10, seed=123, print=F)
impNew <- mice(mammalsleep[ , -1], maxit = 10, print=F)
plot(impNew)
plot(impNew)
rm(list = ls())
require(mice)
require(lattice)
set.seed(123) # Means our outcomes will be replicable
ini <- mice(mammalsleep[, -1], maxit=0, print=F)
meth<- ini$meth
pred <- ini$predictorMatrix
pred[c("sws", "ps"), "ts"] <- 0
meth["ts"]<- "~ I(sws + ps)"
pas.imp <- mice(mammalsleep[, -1], meth=meth, pred=pred, maxit=10, seed=123, print=F)
plot(pas.imp) # we can see these plots have a much better covergence due to how their standard deviation is
# so much lower than before (in vignette 3)
# post processing part
rm(list = ls())
ini <- mice(boys, maxit = 0)
meth <- ini$meth
meth["tv"] <- "norm"
post <- ini$post
post["tv"] <- "imp[[j]][, i] <- squeeze(imp[[j]][, i], c(1, 25))"
imp <- mice(boys, meth=meth, post=post, print=FALSE)
# Compare the imputed values and histograms of tv for the solution obtained by pmm to the constrained solution
# (created with norm, constrained between 1 and 25).
imp.pmm <- mice(boys, print=FALSE)
table(complete(imp)$tv)
table(complete(imp.pmm)$tv)
densityplot(imp, ~tv)
tv <- c(complete(imp.pmm)$tv, complete(imp)$tv)
method <- rep(c("pmm", "norm"), each = nrow(boys))
tvm <- data.frame(tv = tv, method = method)
histogram( ~tv | method, data = tvm, nint = 25)
help(boys)
plot(imp, c("bmi"))
imp <-mice(boys, meth=meth, pred=pred, print=FALSE)
pred<-ini$pred
pred[c("hgt", "wgt"), "bmi"] <- 0 # to remove circularity which is giving us some dodgy imputations
imp <-mice(boys, meth=meth, pred=pred, print=FALSE)
xyplot(imp, bmi ~ I(wgt / (hgt / 100)^2), na.groups = miss,
cex=c(1, 1), pch=c(1, 20),
ylab="BMI (kg/m2) Imputed", xlab="BMI (kg/m2) Calculated")
xyplot(imp, bmi ~ I(wgt / (hgt / 100)^2), na.groups = miss,
cex=c(1, 1), pch=c(1, 20),
ylab="BMI (kg/m2) Imputed", xlab="BMI (kg/m2) Calculated")
miss <- is.na(imp$data$bmi) # This part is to show whether the relationship between height,
xyplot(imp, bmi ~ I(wgt / (hgt / 100)^2), na.groups = miss,
cex=c(1, 1), pch=c(1, 20),
ylab="BMI (kg/m2) Imputed", xlab="BMI (kg/m2) Calculated")
tv <- c(complete(imp.pmm)$tv, complete(imp)$tv)
method <- rep(c("pmm", "norm"), each = nrow(boys))
tvm <- data.frame(tv = tv, method = method)
histogram( ~tv | method, data = tvm, nint = 25) # Looking at this plot, we would say that the norm,
# constrained data is more realistic
miss <- is.na(imp$data$bmi) # This part is to show whether the relationship between height,
xyplot(imp, bmi ~ I (wgt / (hgt / 100)^2), # weight and BMI is kept in the imputed data
na.groups = miss, cex = c(0.8, 1.2), pch = c(1, 20),
ylab = "BMI (kg/m2) Imputed", xlab = "BMI (kg/m2) Calculated")
# This relationship isn't kept and it means we need to use passive imputation:
meth<- ini$meth
meth["bmi"]<- "~ I(wgt / (hgt / 100)^2)"
imp <- mice(boys, meth=meth, print=FALSE)
xyplot(imp, bmi ~ I(wgt / (hgt / 100)^2), na.groups = miss, # This shows that the relationship has now been corrected
cex = c(1, 1), pch = c(1, 20),
ylab = "BMI (kg/m2) Imputed", xlab = "BMI (kg/m2) Calculated")
plot(imp, c("bmi")) # convergence of BMI alone
pred<-ini$pred
pred[c("hgt", "wgt"), "bmi"] <- 0 # to remove circularity which is giving us some dodgy imputations
imp <-mice(boys, meth=meth, pred=pred, print=FALSE)
xyplot(imp, bmi ~ I(wgt / (hgt / 100)^2), na.groups = miss,
cex=c(1, 1), pch=c(1, 20),
ylab="BMI (kg/m2) Imputed", xlab="BMI (kg/m2) Calculated")
plot(imp, c("bmi"))
con <- url("https://www.gerkovink.com/mimp/popular.RData")
# Vignette 5 - Imputing multi-level data ---------------------------------------------------------
rm(list = ls())
require(mice)
require(lattice)
require(pan)
set.seed(123) # Means our outcomes will be replicable
con <- url("https://www.gerkovink.com/mimp/popular.RData")
load(con)
md.pattern(popNCR[ , -5])
# Our focus is to see if the missingness of one variable is dependent on another
# Specifically, does missingness of popular depend on popteach
histogram(~ popteach | is.na(popular), data=popNCR)
ini <- mice(popNCR, maxit = 0)
meth <- ini$meth
meth[c(3, 5, 6, 7)] <- "norm"
pred <- ini$pred
pred[, "class"] <- 0
pred[, "pupil"] <- 0
imp1 <- mice(popNCR, meth = meth, pred = pred, print = FALSE)
data.frame(vars = names(popNCR[c(6, 7, 5)]),
observed = c(icc(aov(popular ~ class, popNCR)),
icc(aov(popteach ~ class, popNCR)),
icc(aov(texp ~ class, popNCR))),
norm     = c(icc(aov(popular ~ class, complete(imp1))),
icc(aov(popteach ~ class, complete(imp1))),
icc(aov(texp ~ class, complete(imp1)))))
pred <- ini$pred
pred[, "pupil"] <- 0
imp2 <- mice(popNCR, meth = meth, pred = pred, print = FALSE)
data.frame(vars = names(popNCR[c(6, 7, 5)]),
observed  = c(icc(aov(popular ~ class, popNCR)),
icc(aov(popteach ~ class, popNCR)),
icc(aov(texp ~ class, popNCR))),
norm      = c(icc(aov(popular ~ class, complete(imp1))),
icc(aov(popteach ~ class, complete(imp1))),
icc(aov(texp ~ class, complete(imp1)))),
normclass = c(icc(aov(popular ~ class, complete(imp2))),
icc(aov(popteach ~ class, complete(imp2))),
icc(aov(texp ~ class, complete(imp2)))))
plot(imp2, c("popular", "texp", "popteach"))
imp3 <- mice.mids(imp2, maxit = 10)
plot(imp3, c("popular", "texp", "popteach"))
plot(imp2, c("popular", "texp", "popteach"))
plot(imp3, c("popular", "texp", "popteach"))
densityplot(imp4)
imp4 <- mice(popNCR) # using predictive mean matching with all variables
densityplot(imp4)
data.frame(vars      = names(popNCR[c(6, 7, 5)]),
observed  = c(icc(aov(popular ~ class, popNCR)),
icc(aov(popteach ~ class, popNCR)),
icc(aov(texp ~ class, popNCR))),
norm      = c(icc(aov(popular ~ class, complete(imp1))),
icc(aov(popteach ~ class, complete(imp1))),
icc(aov(texp ~ class, complete(imp1)))),
normclass = c(icc(aov(popular ~ class, complete(imp2))),
icc(aov(popteach ~ class, complete(imp2))),
icc(aov(texp ~ class, complete(imp2)))),
pmm       = c(icc(aov(popular ~ class, complete(imp4))),
icc(aov(popteach ~ class, complete(imp4))),
icc(aov(texp ~ class, complete(imp4)))),
orig      = c(icc(aov(popular ~ as.factor(class), popular)),
icc(aov(popteach ~ as.factor(class), popular)),
icc(aov(texp ~ as.factor(class), popular))))
# Using new multilevel imputation methods
rm(list = ls())
ini <- mice(popNCR2, maxit = 0)
pred <- ini$pred
pred["popular", ] <- c(0, -2, 2, 2, 2, 0, 2)
rm(list = ls())
require(mice)
require(lattice)
require(pan)
set.seed(123) # Means our outcomes will be replicable
ini <- mice(popNCR2, maxit = 0)
pred <- ini$pred
pred["popular", ] <- c(0, -2, 2, 2, 2, 0, 2)
con <- url("https://www.gerkovink.com/mimp/popular.RData")
load(con)
md.pattern(popNCR[ , -5]) # Missing data pattern without column 5 (texpS)
ini <- mice(popNCR2, maxit = 0)
pred <- ini$pred
pred["popular", ] <- c(0, -2, 2, 2, 2, 0, 2)
meth <- ini$meth
meth <- c("", "", "", "", "", "2l.norm", "")
imp5 <- mice(popNCR2, pred = pred, meth=meth, print = FALSE)
densityplot(imp5, ~popular, ylim = c(0, 0.35), xlim = c(-1.5, 10))
densityplot(imp4, ~popular, ylim = c(0, 0.35), xlim = c(-1.5, 10))
rm(list = ls())
require(mice)
require(lattice)
require(pan)
set.seed(123) # Means our outcomes will be replicable
con <- url("https://www.gerkovink.com/mimp/popular.RData")
load(con)
md.pattern(popNCR[ , -5]) # Missing data pattern without column 5 (texpS)
# Our focus is to see if the missingness of one variable is dependent on another
# Specifically, does missingness of popular depend on popteach
histogram(~ popteach | is.na(popular), data=popNCR) # histograms for popteach one for popular
# being missing (true) and one not missing
# We do see that the histogram for the missing popular (TRUE) is further to the right than the
# histogram for observed popular (FALSE). This would indicate a right-tailed MAR missingness.
histogram(~ popular | is.na(popteach), data = popNCR) # There is also right tailed missingness
# in the other direction too
icc(aov(popteach ~ class, data = popNCR))
icc(aov(popular ~ as.factor(class), data = popNCR))
icc(aov(texp ~ class, data = popNCR))
ini <- mice(popNCR, maxit = 0)
meth <- ini$meth
meth[c(3, 5, 6, 7)] <- "norm"
pred <- ini$pred
pred[, "class"] <- 0
pred[, "pupil"] <- 0
imp1 <- mice(popNCR, meth = meth, pred = pred, print = FALSE)
data.frame(vars = names(popNCR[c(6, 7, 5)]),
observed = c(icc(aov(popular ~ class, popNCR)),
icc(aov(popteach ~ class, popNCR)),
icc(aov(texp ~ class, popNCR))),
norm     = c(icc(aov(popular ~ class, complete(imp1))),
icc(aov(popteach ~ class, complete(imp1))),
icc(aov(texp ~ class, complete(imp1)))))
pred <- ini$pred
pred[, "pupil"] <- 0
imp2 <- mice(popNCR, meth = meth, pred = pred, print = FALSE)
data.frame(vars = names(popNCR[c(6, 7, 5)]),
observed  = c(icc(aov(popular ~ class, popNCR)),
icc(aov(popteach ~ class, popNCR)),
icc(aov(texp ~ class, popNCR))),
norm      = c(icc(aov(popular ~ class, complete(imp1))),
icc(aov(popteach ~ class, complete(imp1))),
icc(aov(texp ~ class, complete(imp1)))),
normclass = c(icc(aov(popular ~ class, complete(imp2))),
icc(aov(popteach ~ class, complete(imp2))),
icc(aov(texp ~ class, complete(imp2)))))
plot(imp2, c("popular", "texp", "popteach"))
imp3 <- mice.mids(imp2, maxit = 10, print = FALSE)
plot(imp3, c("popular", "texp", "popteach"))
imp4 <- mice(popNCR) # using predictive mean matching with all variables
densityplot(imp4) # in this plot the imputed data clearly matches the observed data
data.frame(vars      = names(popNCR[c(6, 7, 5)]),
observed  = c(icc(aov(popular ~ class, popNCR)),
icc(aov(popteach ~ class, popNCR)),
icc(aov(texp ~ class, popNCR))),
norm      = c(icc(aov(popular ~ class, complete(imp1))),
icc(aov(popteach ~ class, complete(imp1))),
icc(aov(texp ~ class, complete(imp1)))),
normclass = c(icc(aov(popular ~ class, complete(imp2))),
icc(aov(popteach ~ class, complete(imp2))),
icc(aov(texp ~ class, complete(imp2)))),
pmm       = c(icc(aov(popular ~ class, complete(imp4))),
icc(aov(popteach ~ class, complete(imp4))),
icc(aov(texp ~ class, complete(imp4)))),
orig      = c(icc(aov(popular ~ as.factor(class), popular)),
icc(aov(popteach ~ as.factor(class), popular)),
icc(aov(texp ~ as.factor(class), popular))))
# Using new multilevel imputation methods
ini <- mice(popNCR2, maxit = 0)
pred <- ini$pred
pred["popular", ] <- c(0, -2, 2, 2, 2, 0, 2)
meth <- ini$meth
meth <- c("", "", "", "", "", "2l.norm", "")
imp5 <- mice(popNCR2, pred = pred, meth=meth, print = FALSE)
densityplot(imp5, ~popular, ylim = c(0, 0.35), xlim = c(-1.5, 10))
densityplot(imp4, ~popular, ylim = c(0, 0.35), xlim = c(-1.5, 10))
plot(density(popular$popular))  #true data
lines(density(complete(imp5)$popular), col = "red", lwd = 2)  #2l.norm
lines(density(complete(imp4)$popular), col = "green", lwd = 2)  #PMM
rm(list = ls()) # clear environment
# To plot the output of a single model - will eventually be for the optimal model parameters
# setting up files for calibration for PHASE project
library(dplyr)
library(lhs)
library(truncnorm)
library(yaml)
library(tidyverse)
setwd("//wsl.localhost/Ubuntu/home/ruairi/ABM_code/abmcodeupdated/ABM_code - with PD")
targets <- read.csv("calibration/Target_data_HFSS_sex.csv")
targets %>%
mutate(upper = meanHFSS + (seHFSS*1.96),
lower = meanHFSS - (seHFSS*1.96))
# read in the output data files
# dir.create("outputs/outputs_newcalibration")
# dir.create("outputs/outputs_newcalibration/outputs")
names <- (Sys.glob("outputs/*.csv")) # reads in files that end with .csv
# names <- names[1:100]
files <- lapply(names, read.csv)
names <- gsub("/outputs/", "", names)
names <- gsub("_yaml_0", "", names)
names <- parse_number(names)
names(files) <- names
for(i in 1:length(files)){
files[[i]]$sampleno <- names[i]
}
postprocess <- function(data){
data <- data %>%
mutate(meanHFSS_m = HFSSQuantMale/Male,
meanHFSS_f = HFSSQuantFemale/Female,
meanHFSS_low_male = HFSSQuantSESLowMale/SESlowMale,
meanHFSS_medium_male = HFSSQuantSESMedMale/SESmedMale,
meanHFSS_high_male = HFSSQuantSESHighMale/SEShighMale,
meanHFSS_low_female = HFSSQuantSESLowFemale/SESlowFemale,
meanHFSS_medium_female = HFSSQuantSESMedFemale/SESmedFemale,
meanHFSS_high_female = HFSSQuantSESHighFemale/SEShighFemale,
SurveyYear = tick/365 + 2008) %>%
# dplyr::select(SurveyYear, sampleno, meanHFSS_low_male, meanHFSS_medium_male, meanHFSS_high_male,
#               meanHFSS_low_female, meanHFSS_medium_female, meanHFSS_high_female) %>%
dplyr::select(SurveyYear, sampleno, meanHFSS_m, meanHFSS_f) %>%
pivot_longer(meanHFSS_m:meanHFSS_f) %>%
separate(name, into=c("meanHFSSsim","Sex")) %>%
dplyr::select(-meanHFSSsim) %>%
rename(meanHFSSsim=value)
return(data)
}
postprocess_schema <- function(data){
data <- data %>%
mutate(schema1_male = countschema1Male/Male/365,
schema2_male = countschema2Male/Male/365,
schema3_male = countschema3Male/Male/365,
schema4_male = countschema4Male/Male/365,
schema5_male = countschema5Male/Male/365,
schema1_female = countschema1Female/Female/365,
schema2_female = countschema2Female/Female/365,
schema3_female = countschema3Female/Female/365,
schema4_female = countschema4Female/Female/365,
schema5_female = countschema5Female/Female/365,
SurveyYear = tick/365 + 2008) %>%
# dplyr::select(SurveyYear, sampleno, meanHFSS_low_male, meanHFSS_medium_male, meanHFSS_high_male,
#               meanHFSS_low_female, meanHFSS_medium_female, meanHFSS_high_female) %>%
dplyr::select(SurveyYear, sampleno, schema1_male, schema2_male, schema3_male, schema4_male,
schema5_male, schema1_female, schema2_female, schema3_female, schema4_female,
schema5_female) %>%
pivot_longer(schema1_male: schema5_female) %>%
separate(name, into=c("schema","Sex"))
# dplyr::select(-meanHFSSsim) %>%
# rename(meanHFSSsim=value)
return(data)
}
files <- lapply(files, postprocess)
# files <- lapply(files, postprocess_schema)
files <- do.call(rbind,files)
files$Sex <- ifelse(files$Sex=="m","Men","Women")
targets$Sex <- ifelse(targets$Sex=="m","Men","Women")
files <- left_join(files,targets)
upper = quantile(files$meanHFSSsim, probs = 0.75)
lower = quantile(files$meanHFSSsim, probs = 0.25)
ggplot(data=files, aes(x=SurveyYear, y=meanHFSSsim, colour=as.factor(sampleno))) +
geom_line(linewidth=1) +
geom_line(aes(x=SurveyYear, y=meanHFSS), colour="black", linewidth=1.5) +
geom_ribbon(aes(ymin=lower, ymax=upper), colour=NA, fill="grey", alpha=0.3) +
geom_vline(xintercept = 2015, linetype = "dotted", color = "blue") +
ggtitle("Calibrated HFSS consumption") +  # Add a title to the plot
facet_grid(rows=vars(Sex)) + ylim(0,NA) +
theme_bw() +
scale_color_discrete(name="Sample Number") +
theme(#legend.position="none",
legend.title = element_text(size = 18), # legend.title=element_blank(),
strip.background = element_rect(fill="white"),
text = element_text(size=18)) +
ylab("Mean Kcal per day HFSS") + xlab("Year")
ggsave("calibration/plots/PHASE_full_optimal.png", dpi=300, width=33, height=19,
units="cm")
# compare <- files %>%
#   mutate(abserror = abs(meanHFSSsim - meanHFSS),
#          denoms = sqrt(seHFSS^2),
#          implausibility = abserror/denoms) %>%
#   group_by(sampleno) %>%
#   summarise(implausibility = max(implausibility))
#
# write.csv(compare, "calibration/implausibility.csv", row.names=F)
#
# compare <- read.csv("calibration/implausibility.csv")
#
# best <- compare %>% ungroup() %>%
#   mutate(rank = ntile(implausibility, nrow(.))) %>%
#   filter(rank<=5) # originally set to 5, this just selects the best results from the generated data. The least implausible is the best
#
# ids <- best$sampleno
#
# # look at the values with the best implausibility
# lhs <- read.csv("calibration/lhs.csv") %>% filter(SampleNum %in% ids)
#
# # now plot those best runs
#
# topruns <- files %>%
#   filter(sampleno %in% ids)
#
# error <- topruns %>% mutate(error = abs(meanHFSSsim-meanHFSS)/meanHFSS) %>%
#   group_by(sampleno) %>% summarise(mean=mean(error))
#
# # ggplot(data=topruns, aes(x=SurveyYear, y=value, colour=as.factor(sampleno))) +
# #   geom_line(linewidth=1) +
# #   facet_grid(rows=vars(Sex), cols=vars(schema)) +
# #   ylim(0,NA) +
# #   theme_bw() +
# #   theme(legend.position="none",
# #         legend.title=element_blank(),
# #         strip.background = element_rect(fill="white"),
# #         text = element_text(size=18)) + ylab("Proportion of calories from schema") +
# #   xlab("Year")
# #
# # ggsave("calibration/plots/PHASE_bestruns_schemaview.png", dpi=300, width=33, height=19,
# #        units="cm")
#
# upper = quantile(topruns$meanHFSSsim, probs = 0.75)
# lower = quantile(topruns$meanHFSSsim, probs = 0.25)
#
# ggplot(data=topruns, aes(x=SurveyYear, y=meanHFSSsim, colour=as.factor(sampleno))) +
#   geom_line(linewidth=1) +
#   geom_line(aes(x=SurveyYear, y=meanHFSS), colour="black", linewidth=1.5) +
#   geom_ribbon(aes(ymin=lower, ymax=upper), colour=NA, fill="grey", alpha=0.3) +
#   facet_grid(rows=vars(Sex)) + ylim(0,NA) +
#   theme_bw() +
#   scale_color_discrete(name="Sample Number") +
#   theme(#legend.position="none",
#     legend.title = element_text(size = 18), # legend.title=element_blank(),
#     strip.background = element_rect(fill="white"),
#     text = element_text(size=18)) + ylab("Mean Kcal per day HFSS") +
#   xlab("Year")
#
# ggsave("calibration/plots/PHASE_top10_calibration.png", dpi=300, width=33, height=19,
#        units="cm")
#
